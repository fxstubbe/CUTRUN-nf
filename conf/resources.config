// Function to ensure that resource requirements don't go beyond
// a maximum limit
def check_max(obj, type){
    def limits = workflow.config.process.resourceLimits ?: [:]

    switch(type) {
        case "memory":
            def max_mem = limits.memory ?: obj
            return obj > max_mem ? max_mem : obj

        case "time":
            def max_time = limits.time ?: obj
            return obj > max_time ? max_time : obj

        case "cpus":
            def max_cpus = limits.cpus ?: obj
            return obj > max_cpus ? max_cpus : obj

        default:
            return obj
    }
}


process {

    // Default resource settings with scaling and check_max
    cpus   = { check_max( 1 * task.attempt, 'cpus' ) }
    memory = { check_max( 6.GB * task.attempt, 'memory' ) }
    time   = { check_max( 4.h * task.attempt, 'time' ) }

    errorStrategy = { task.exitStatus in ((130..145) + 104 + 175) ? 'retry' : 'finish' }
    maxRetries    = 1
    maxErrors     = '-1'

    //
    // Label-based resource overrides
    //
process {

    // Default resources (fallback)
    cpus   = { check_max(2 * task.attempt, 'cpus') }
    memory = { check_max(8.GB * task.attempt, 'memory') }
    time   = { check_max(1.h * task.attempt, 'time') }
    errorStrategy = { task.exitStatus in ((130..145) + 104 + 175) ? 'retry' : 'finish' }
    maxRetries = 1
    maxErrors  = '-1'

    // Label-based resource overrides
    withLabel:process_single {
        cpus   = { check_max(1 * task.attempt, 'cpus') }
        memory = { check_max(4.GB * task.attempt, 'memory') }
        time   = { check_max(1.h * task.attempt, 'time') }  // quick tasks
    }

    withLabel:process_low {
        cpus   = { check_max(2 * task.attempt, 'cpus') }
        memory = { check_max(8.GB * task.attempt, 'memory') }
        time   = { check_max(2.h * task.attempt, 'time') }  // small mapping or QC
    }

    withLabel:process_medium {
        cpus   = { check_max(4 * task.attempt, 'cpus') }
        memory = { check_max(16.GB * task.attempt, 'memory') }
        time   = { check_max(4.h * task.attempt, 'time') }  // standard Bowtie2 runs
    }

    withLabel:process_high {
        cpus   = { check_max(8 * task.attempt, 'cpus') }
        memory = { check_max(32.GB * task.attempt, 'memory') }
        time   = { check_max(6.h * task.attempt, 'time') }  // multiple Bowtie2 passes or large DeepTools jobs
    }

    withLabel:process_long {
        time = { check_max(12.h * task.attempt, 'time') }   // long-running aggregations
    }

    withLabel:process_high_memory {
        memory = { check_max(128.GB * task.attempt, 'memory') }  // very large BAM or genome-wide coverage
    }

}


    //
    // Error handling labels
    //
    withLabel:error_ignore {
        errorStrategy = 'ignore'
    }

    withLabel:error_retry {
        errorStrategy = 'retry'
        maxRetries    = 2
    }

    //
    // GPU label
    //
    withLabel:process_gpu {
        ext.use_gpu = { workflow.profile.contains('gpu') }
        accelerator = { workflow.profile.contains('gpu') ? 1 : null }
    }
}